var util = require('util')
var fs = require('fs')
var path = require('path')

var Narcissus = require('./narcissus')
var tokens = Narcissus.definitions.tokens
var pp = Narcissus.decompiler.pp
eval(Narcissus.definitions.consts);

var snippets = require('./snippets')
var idents = require('./idents')

var function_vars

/**
 *  Transform a block of Cinch source code into pure Javascript.
 */
exports.transformSource = function(source) {
    var script = Narcissus.parser.parse(source)
    transform_script(script)
    return pp(script) + '\n'
}

/**
 *  Enable raw Cinch modules to be loaded by 'require()'.
 *  
 *  - options.extension - File extension to register.  Default: ".js_"
 *  - options.preamble - Text to be prepended to the output.
 *  - options.saveSource - Save output with .js extension.  Default: false
 *  - options.saveParseTree - Save Narcissus parse tree for debugging.  Default: false
 */
exports.registerExtension = function(options) {
    options = options || {}
    options.preamble = options.preamble || "/*** Generated by Cinch ***/\n";

    // force require() to check for .js_ before .js
    var js_extension = require.extensions['.js']
    delete require.extensions['.js']

    require.extensions[options.extension || '.js_'] = function(module, filename_) {
        var dirname = path.dirname(filename_)
        var ext = path.extname(filename_)
        var basename = path.basename(filename_, ext)
        var filename = path.join(dirname, basename + '.js')

        var source = fs.readFileSync(filename_, 'utf8');

        try {
            Narcissus.parser.parse(source)
        } catch (err) {
            module._compile(source, filename_)
            throw err
        }

        if (options.saveParseTree) {
            var script = Narcissus.parser.parse(source)
            strip(script)
            fs.writeFileSync(filename_ + '.parsed.json', JSON.stringify(script), 'utf8')

            var script = Narcissus.parser.parse(source)
            transform_script(script)
            strip(script)
            fs.writeFileSync(filename + '.parsed.json', JSON.stringify(script), 'utf8')
        }

        var script = Narcissus.parser.parse(source)
        transform_script(script)
        var transformed = options.preamble + pp(script) + '\n'

    	if (options.saveSource) {
    		fs.writeFileSync(filename, transformed, 'utf8');
    	}

        module._compile(transformed, filename)
    }

    require.extensions['.js'] = js_extension
}

/**
 *  Transform a parsed script in place.  Returns nothing.
 */
function transform_script(script) {
    idents.reset()
    scan_for_functions_to_transform(script).forEach(transform_function)

    // Post-processing.  The script is already valid, but we clean up redundancies to improve readability of the output.
    replace_passthrough_callbacks(script)
    replace_passthrough_functions(script)
    inline_functions_only_called_once(script)
}

/**
 *  Returns an array of all function definitions in the script.
 *  script.funDecls would be inadequate for the purpose because it does not
 *  include nested functions.
 */
function scan_for_functions_to_transform(script) {
    var functions = []
    tree_forEach(script.children, function(n) {
        if (is_cinched_function_definition(n)) {
            functions.push(n)
        }
    })
    return functions
}

/**
 *  "Passthrough functions" take no arguments and merely call another function
 *  with no arguments.  The other function may as well be called directly.  The
 *  modifications are made in place.
 *  
 *  foo()
 *  function foo() {
 *      bar()
 *  }
 *  
 *  // ...becomes...
 *  
 *  bar()
 */
function replace_passthrough_functions(script) {
    var replacement_names = {}
    var replaced_functions = {}

    tree_forEach(script.children, function(n) {
        if (is_passthrough_function(n)) {
            replacement_names[n.name] = n.body.children[0].children[0].value
            replaced_functions[n.name] = n
        }
    })

    tree_forEach(script.children, function(n) {
        if (n.type === CALL) {
            var name = n.children[0].value
            var new_name = replacement_names[name]
            if (new_name) {
                n.children[0].value = new_name
            }
        }
    })

    for (var name in replaced_functions) {
        var replaced_function_definition = replaced_functions[name]
        tree_forEach(script.children, function(n) {
            if (n.children) {
                for (var i in n.children) {
                    if (n.children[i] === replaced_function_definition) {
                        n.children.splice(i, 1)
                        return
                    }
                }
            }
        })
    }

    function is_passthrough_function(n) {
        return n.type === FUNCTION
            && n.params
            && n.params.length === 0
            && n.body
            && n.body.type === SCRIPT
            && n.body.children
            && n.body.children.length === 1
            && n.body.children[0].type === CALL
            && n.body.children[0].children
            && n.body.children[0].children.length === 2
            && n.body.children[0].children[0].type === IDENTIFIER
            && n.body.children[0].children[0].value // <- replacement name
            && n.body.children[0].children[1].type === LIST
            && n.body.children[0].children[1].children
            && n.body.children[0].children[1].children.length === 0
    }
}

/**
 *  For any generated functions that are only called once by a single statement
 *  alone in a block, replace the function call with the body of the function
 *  definition.  These constructs are often produced by the transformation of
 *  an 'if' statement with no subsequent statements.  The modifications are
 *  made in place.
 *  
 *  {
 *      foo()
 *  }
 *  function foo() {
 *      bar()
 *      baz()
 *  }
 *  
 *  // ...becomes...
 *  
 *  {
 *      bar()
 *      baz()
 *  }
 */
function inline_functions_only_called_once(script) {
    var generated_functions = {}
    tree_forEach(script.children, function(n) {
        if (n.type === FUNCTION && n.generated && n.name) {
            generated_functions[n.name] = n
        }
    })

    var reference_counts = {}
    var found = false
    tree_forEach(script.children, function(n) {
        if (n.type === IDENTIFIER && generated_functions[n.value]) {
            found = true
            if (reference_counts[n.value]) {
                reference_counts[n.value] += 1
            } else {
                reference_counts[n.value] = 1
            }
        }
    })

    tree_forEach(script.children, function(n) {
        if (is_block_with_single_call(n)) {
            var name = n.children[0].children[0].value
            n.children = generated_functions[name].body.children
            delete_node(script, generated_functions[name])
        }
    })

    function is_block_with_single_call(n) {
        return n.type === BLOCK
            && n.children
            && n.children.length === 1
            && n.children[0].type === CALL
            && n.children[0].children
            && n.children[0].children.length === 2
            && n.children[0].children[0].type === IDENTIFIER
            && reference_counts[n.children[0].children[0].value] === 1
    }

    function delete_node(script, node) {
        tree_forEach(script, function(n) {
            if (n.children) {
                for (var i in n.children) {
                    if (n.children[i] === node) {
                        n.children.splice(i, 1)
                        return
                    }
                }
            }
        })
    }
}

/**
 *  "Passthrough callbacks" are callbacks that merely pass the error or result
 *  on to another callback.  The other callback might as well be called
 *  directly.  The modifications are made in place.
 *  
 *  function(err, result) {
 *      if (err) return callback(err)
 *      return callback(null, result)
 *  }
 *  
 *  // ...becomes...
 *  
 *  callback
 */
function replace_passthrough_callbacks(script) {
    tree_forEach(script.children, function(n) {
        if (is_passthrough_for_callback(n)) {
            n.type = IDENTIFIER
            n.value = n.body.children[0].thenPart.value.children[0].value
            delete n.params
            delete n.body
        }
    })

    function is_passthrough_for_callback(n) {
        var callback_name, result_name

        function say(s) {
            console.log(s)
            return true
        }

        return n.type === FUNCTION
            && n.params
            && n.params.length === 2
            && n.params[0] === 'err'
            && (result_name = n.params[1])
            && n.body
            && n.body.type === SCRIPT
            && n.body.children
            && n.body.children.length === 2
            && n.body.children[0].type === IF
            && n.body.children[0].condition
            && n.body.children[0].condition.type === IDENTIFIER
            && n.body.children[0].condition.value === 'err'
            && n.body.children[0].thenPart
            && n.body.children[0].thenPart.type === RETURN
            && n.body.children[0].thenPart.value
            && n.body.children[0].thenPart.value.type === CALL
            && n.body.children[0].thenPart.value.children
            && n.body.children[0].thenPart.value.children.length === 2
            && n.body.children[0].thenPart.value.children[0].type === IDENTIFIER
            && (callback_name = n.body.children[0].thenPart.value.children[0].value)
            && n.body.children[0].thenPart.value.children[1].type === LIST
            && n.body.children[0].thenPart.value.children[1].children
            && n.body.children[0].thenPart.value.children[1].children.length === 1
            && n.body.children[0].thenPart.value.children[1].children[0].type === IDENTIFIER
            && n.body.children[0].thenPart.value.children[1].children[0].value == 'err'
            && n.body.children[0].elsePart == null // or undefined
            && n.body.children[1].type === RETURN
            && n.body.children[1].value
            && n.body.children[1].value.type === CALL
            && n.body.children[1].value.children
            && n.body.children[1].value.children.length === 2
            && n.body.children[1].value.children[0].type === IDENTIFIER
            && n.body.children[1].value.children[0].value === callback_name
            && n.body.children[1].value.children[1].type === LIST
            && n.body.children[1].value.children[1].children
            && n.body.children[1].value.children[1].children.length === 2
            && n.body.children[1].value.children[1].children[0].type === NULL
            && n.body.children[1].value.children[1].children[1].type === IDENTIFIER
            && n.body.children[1].value.children[1].children[1].value === result_name
    }
}

/**
 *  Transform a function in place.  Returns nothing.
 */
function transform_function(func) {
    if (ends_with_underscore(func.name)) {
        function_vars = {}
        idents.push_callback()
        func.name = strip_underscore(func.name)
        func.params.push(idents.callback.value)
        func.body.children.push({
            type: RETURN,
            implicit: true,
        })
        func.body.children = transform_statements(func.body.children)
        idents.pop_callback()
    }
}

/**
 *  Returns a set of transformed statements.  The originals may be mangled in the process and should be discarded.
 */
function transform_statements(statements) {
    var statement = statements.shift()
    if (!statement) return []
    
    return transform_statement(statement, statements)
}

/**
 *  Transforms a statement *and* those that follow it.  Returns an array of
 *  transformed statements.
 *  
 *  The transformation of a statement may involve the statements following it.
 *  For instance, if the statement contains a transformed function call, the
 *  function must be called first, and both the statement and those that follow
 *  it must be placed inside the function's callback.
 *  
 *  This process usually recurses, but not always.  'return' and 'throw'
 *  statements return pseudo-synchronous control flow, and therefore can
 *  discard any subsequent statements.
 */
function transform_statement(statement, subsequent_statements) {
    var transformation = statement_transformations[tokens[statement.type]]
    if (transformation) {
        var transformed = transformation(statement, subsequent_statements)
        if (transformed) {
            return transformed
        }
    } else {
        //util.debug('ignoring ' + tokens[statement.type] + ': ' + pp(statement))
    }
    return [statement].concat(transform_statements(subsequent_statements))
}

var statement_transformations = {
    'throw': function(statement, subsequent_statements) {
        if (expression_contains_cinched_function_call(statement.exception)) {
            return transform_cinched_function_call_in_expression(statement.exception, statement, subsequent_statements)
        }

        return [
            snippets.return_callback(statement.exception)
        ]
    },

    'return': function(statement, subsequent_statements) {
        if (!statement.value) {
            return [
                snippets.return_callback_null()
            ]
        }

        if (expression_contains_cinched_function_call(statement.value)) {
            return transform_cinched_function_call_in_expression(statement.value, statement, subsequent_statements)
        }

        if (expression_contains_regular_function_call(statement.value)) {
            var ident = idents.get('retval')
            
            return [
                snippets.try_catch_return_callback_err([
                    snippets.assign(ident, statement.value)
                ]),
                snippets.return_callback_value(ident),
            ]
        }

        return [
            snippets.return_callback_value(statement.value)
        ]
    },
    
    'var': function(statement, subsequent_statements) {
        for (var i in statement.children) {
            var expression = statement.children[i].initializer
            if (!expression) continue
            if (expression_contains_cinched_function_call(expression)) {
                return transform_cinched_function_call_in_expression(expression, statement, subsequent_statements)
            }
        }

        for (var i in statement.children) {
            var expression = statement.children[i].initializer
            if (!expression) continue
            if (expression_contains_regular_function_call(expression)) {
                return [
                    snippets.try_catch_return_callback_err([
                        statement
                    ]),
                ].concat(transform_statements(subsequent_statements))
            }
        }

        // Remove redundant 'var' statements, in order to maintain scoping
        // semantics in case they get wrapped in a generated function.
        // Initializers become assignments.
        for (var i in statement.children) {
            var child = statement.children[i]
            var name = child.name
            if (function_vars[name]) {
                util.debug('duplicate var ' + name)
                statement.children.splice(i, 1)
                if (child.initializer) {
                    var assign = snippets.assign(snippets.ident(name), child.initializer)
                    if (statement.children.length) {
                        return transform_statement(
                            [assign].concat([statement]).concat(subsequent_statements)
                        )
                    } else {
                        return transform_statement(assign, subsequent_statements)
                    }
                } else {
                    return transform_statement(statement, subsequent_statements)
                }
            }
            util.debug('var ' + name)
            function_vars[name] = name
        }
    },

    ';': function(statement, subsequent_statements) {
        if (expression_contains_cinched_function_call(statement.expression)) {
            return transform_cinched_function_call_in_expression(statement.expression, statement, subsequent_statements)
        }
        
        if (expression_contains_regular_function_call(statement.expression)) {
            return [
                snippets.try_catch_return_callback_err([
                    statement
                ]),
            ].concat(transform_statements(subsequent_statements))
        }
    },

    'if': function(statement, subsequent_statements) {
        if (expression_contains_cinched_function_call(statement.condition)) {
            return transform_cinched_function_call_in_expression(statement.condition, statement, subsequent_statements)
        }

        if (expression_contains_regular_function_call(statement.condition)) {
            return extract_expression_into_try(statement.condition, statement, subsequent_statements)
        }

        var rest_enabled = (subsequent_statements.length > 0)

        var then_block_ident = idents.get('then_block')
        if (statement.thenPart.type !== BLOCK) {
            statement.thenPart = {
                type: BLOCK,
                children: [
                    statement.thenPart
                ]
            }
        }
        if (statement.elsePart) {
            if (statement.elsePart.type !== BLOCK) {
                statement.elsePart = {
                    type: BLOCK,
                    children: [
                        statement.elsePart
                    ]
                }
            }
            var else_block_ident = idents.get('else_block')
        }
        if (rest_enabled) {
            var rest_block_ident = idents.get('rest_block')
        }
        
        if (rest_enabled) {
            statement.thenPart.children.push(snippets.call(rest_block_ident, []))
            if (statement.elsePart) {
                statement.elsePart.children.push(snippets.call(rest_block_ident, []))
            }
        }

        var then_func = snippets.function(then_block_ident, [], transform_statements(
            statement.thenPart.children
        ))
        if (statement.elsePart) {
            var else_func = snippets.function(else_block_ident, [], transform_statements(
                statement.elsePart.children
            ))
        }
        if (rest_enabled) {
            var rest_func = snippets.function(rest_block_ident, [], transform_statements(subsequent_statements))
        }
        
        var else_call
        if (statement.elsePart) {
            else_call = snippets.call(else_block_ident, [])
        } else if (rest_enabled) {
            else_call = snippets.call(rest_block_ident, [])
        } else {
            else_call = null
        }
        
        var result = [
            snippets.if(
                statement.condition,
                [snippets.call(then_block_ident, [])],
                [else_call]
            )
        ]
        result.push(then_func)
        if (statement.elsePart) {
            result.push(else_func)
        }
        if (rest_enabled) {
            result.push(rest_func)
        }
        return result
    },

    'break': function(statement, subsequent_statements) {
        if (!statement.target.break_ident) {
            throw new Error('break has no target')
        }
        return [{
            type: RETURN,
            value: snippets.call(statement.target.break_ident, [])
        }]
    },

    'continue': function(statement, subsequent_statements) {
        if (!statement.target.continue_ident) {
            throw new Error('continue has no target')
        }
        return [{
            type: RETURN,
            value: snippets.call(statement.target.continue_ident, [])
        }]
    },

    'while': function(statement, subsequent_statements) {
        var ident = idents.get('while_loop')
        statement.break_ident = idents.get('break')
        statement.continue_ident = ident

        return [
            snippets.call(ident, []),
            snippets.function(ident, [], transform_statements([
                snippets.if(statement.condition, statement.body.children.concat([
                    snippets.nextTick(ident)
                ]), [
                    snippets.call(statement.break_ident, [])
                ])
            ])),
            snippets.function(statement.break_ident, [], transform_statements(subsequent_statements))
        ]
    },

    'switch': function(statement, subsequent_statements) {
        if (expression_contains_cinched_function_call(statement.discriminant)) {
            return transform_cinched_function_call_in_expression(statement.discriminant, statement, subsequent_statements)
        }

        var case_idents = []
        for (var i in statement.cases) {
            case_idents.push(idents.get('case'))
        }

        var break_ident = idents.get('break')

        var case_funcs = []

        for (var i in statement.cases) {
            var this_ident = case_idents[parseInt(i)]
            var next_ident = case_idents[parseInt(i) + 1] || break_ident

            var children = statement.cases[i].statements.children
            statement.cases[i].statements.children = [{
                type: RETURN,
                value: snippets.call(this_ident, [])
            }]

            children.push(snippets.call(next_ident, []))

            for (var j in children) {
                if (children[j].type === BREAK) {
                    children.splice(j, children.length, snippets.call(break_ident, []))
                }
            }

            var case_func = snippets.function(case_idents[i], [], transform_statements(children))
            case_funcs.push(case_func)
        }

        var rest_func = snippets.function(break_ident, [], transform_statements(subsequent_statements))

        return [
            statement,
            snippets.call(break_ident, [])
        ].concat(case_funcs).concat([rest_func])
    },

    'try': function(statement, subsequent_statements) {
        var try_block_ident = idents.get('try_block')
        var catch_block_ident = idents.get('catch_block')
        var finally_block_ident = idents.get('finally_block')
        var rest_block_ident = idents.get('rest_block')

        var result = [
            snippets.call(try_block_ident, [])
        ]

        var func = snippets.function(
            try_block_ident,
            [],
            transform_statements(
                snippets.try_prefix(catch_block_ident)
                .concat(statement.tryBlock.children)
                .concat([
                    snippets.call(statement.finallyBlock ? finally_block_ident : rest_block_ident, [])
                ])
            )
        )
        result.push(func)
        
        for (var i in statement.catchClauses) {
            var clause = statement.catchClauses[i]
            var func = snippets.function(
                catch_block_ident,
                [clause.varName],
                transform_statements(clause.block.children.concat([
                    snippets.call(statement.finallyBlock ? finally_block_ident : rest_block_ident, [])
                ]))
            )
            result.push(func)
        }

        if (statement.finallyBlock) {
            var func = snippets.function(
                finally_block_ident,
                [],
                transform_statements(statement.finallyBlock.children.concat([
                    snippets.call(rest_block_ident, [])
                ]))
            )
            result.push(func)
        }

        var func = snippets.function(
            rest_block_ident,
            [],
            transform_statements(subsequent_statements)
        )
        result.push(func)

        return result
    },
    
    'for': function(statement, subsequent_statements) {
        var setup_statement
        if (statement.setup.type === VAR) {
            setup_statement = statement.setup
        } else {
            setup_statement = {
                type: SEMICOLON,
                expression: statement.setup,
            }
        }

        statement.loop_ident = idents.get('for_loop')
        statement.continue_ident = idents.get('continue')
        statement.break_ident = idents.get('break')

        return transform_statements([
            setup_statement,
            snippets.call(statement.loop_ident, []),
            snippets.function(statement.loop_ident, [], transform_statements([
                snippets.if(statement.condition, statement.body.children.concat([
                    snippets.call(statement.continue_ident, [])
                ]), [
                    snippets.call(statement.break_ident, [])
                ])
            ])),
            snippets.function(statement.continue_ident, [], transform_statements([
                {
                    type: SEMICOLON,
                    expression: statement.update
                },
                snippets.nextTick(statement.loop_ident)
            ])),
            snippets.function(statement.break_ident, [], transform_statements(subsequent_statements))
        ])
    },

    'FOR_IN': function(statement, subsequent_statements) {
        if (expression_contains_cinched_function_call(statement.object)) {
            return transform_cinched_function_call_in_expression(statement.object, statement, subsequent_statements)
        }

        var children = statement.body.children

        var props_ident = idents.get('props')
        var iter_ident = idents.get('i')
        
        statement.body.children = [
            {
                type: SEMICOLON,
                expression: snippets.call({
                    type: DOT,
                    children: [ props_ident, snippets.ident('push') ]
                }, [statement.iterator])
            }
        ]

        var for_statement = {
            type: FOR,
            setup: snippets.var(iter_ident, snippets.number(0)),
            condition: snippets.less_than(iter_ident, {
                type: DOT,
                children: [ props_ident, snippets.ident('length') ]
            }),
            update: {
                type: INCREMENT,
                children: [iter_ident],
            },
            body: {
                type: BLOCK,
                children: [
                    snippets.assign(statement.iterator, {
                        type: INDEX,
                        children: [ props_ident, iter_ident ]
                    })
                ].concat(children)
            },
        }

        return [
            snippets.var(props_ident, snippets.array([])),
            statement,
        ].concat(transform_statement(for_statement, subsequent_statements))
    },
}

/*
 *  Search the expression for a function call to transform, then replace it
 *  with a token, make it asynchronous, and place the statement and subsequent
 *  statements inside its callback.  Returns an array of transformed statements.
 *  
 *  The expression should be part of the statement, such as the condition of an
 *  'if' statement.
 *  
 *  var x = foo_()
 *  bar()
 *  
 *  //...becomes...
 *  
 *  foo(function(err, result) {
 *      var x = result
 *      bar()
 *  })
 */
function transform_cinched_function_call_in_expression(expression, statement, subsequent_statements) {
    var ident = idents.get('result')

    var call = find_cinched_function_call(expression)

    strip_call_underscore(call)
    var name_ident = call.children[0]
    var call_parameters = call.children[1].children

    call.type = IDENTIFIER
    call.value = ident.value
    delete call.children

    return [{
        type: RETURN,
        value: snippets.call(name_ident, call_parameters.concat([
            snippets.function_err_result(ident, transform_statement(statement, subsequent_statements))
        ]))
    }]
}

/**
 *  Have the expression evaluated in a try/catch block before the statement.
 *  Should the expression throw, its error will propagate through the callback.
 *  
 *  We can't just wrap the entire statement in a try/catch block because it
 *  might invoke the callback, and we don't want to catch the callback's errors.
 *  
 *  return foo()
 *  
 *  //...becomes...
 *  
 *  try {
 *      var result = foo()
 *  } catch (err) {
 *      return callback(err)
 *  }
 *  return result
 */
function extract_expression_into_try(expression, statement, subsequent_statements) {
    var result_ident = idents.get('result')

    var expression_clone = {
        type: expression.type,
        children: expression.children
    }

    expression.type = IDENTIFIER
    expression.value = result_ident.value
    delete expression.children

    return [
        snippets.try_catch_return_callback_err([
            snippets.var(result_ident, expression_clone)
        ])
    ].concat(transform_statement(statement, subsequent_statements))
}

function is_cinched_function_definition(expression) {
    return expression.type
        && expression.type === FUNCTION
        && expression.name
        && ends_with_underscore(expression.name)
}

function is_cinched_function_call(n) {
    return n.type === CALL
        && ends_with_underscore(call_name(n))
}

/**
 *  Returns the last section of the name of the function being called.
 */
function call_name(n) {
    if (n.children[0].type === IDENTIFIER) {
        return n.children[0].value
    }
    if (n.children[0].type === DOT) {
        return n.children[0].children[1].value
    }
    throw new Error('Can not find name of function called')
}

function expression_contains_cinched_function_call(n) {
    if (is_cinched_function_call(n)) {
        return true
    }

    for (var i in n.children) {
        if (expression_contains_cinched_function_call(n.children[i])) {
            return true
        }
    }

    return false
}

function find_cinched_function_call(n) {
    if (is_cinched_function_call(n)) {
        return n
    }

    for (var i in n.children) {
        var call = find_cinched_function_call(n.children[i])
        if (call) return call
    }

    return null
}

function is_regular_function_call(n) {
    return n.type === CALL
        && n.children[0].type === IDENTIFIER
        && !ends_with_underscore(n.children[0].value)
}

function expression_contains_regular_function_call(n) {
    if (is_regular_function_call(n)) {
        return true
    }

    for (var i in n.children) {
        if (expression_contains_regular_function_call(n.children[i])) {
            return true
        }
    }

    return false
}

function strip_call_underscore(n) {
    if (n.children[0].type === IDENTIFIER) {
        n.children[0].value = strip_underscore(n.children[0].value)
    }
    if (n.children[0].type === DOT) {
        n.children[0].children[1].value = strip_underscore(n.children[0].children[1].value)
    }
}

function ends_with_underscore(s) {
    return (s[s.length - 1] === '_')
}

function strip_underscore(s) {
    if (!ends_with_underscore(s)) throw new Error('thought that had an underscore')
    return s.slice(0, s.length - 1)
}

/**
 *  Apply f() to every node in a parse tree.
 */
function tree_forEach(tree, f) {
    var scan = function(n) {
        if (!n) return

        f(n)

        if (n.forEach)      n.forEach(scan)
        if (n.children)     n.children.forEach(scan)
        if (n.funDecls)     n.funDecls.forEach(scan)
        if (n.catchClauses) n.catchClauses.forEach(scan)
        if (n.cases)        n.cases.forEach(scan)
        
        if (n.initializer)  scan(n.initializer)
        if (n.body)         scan(n.body)
        if (n.expression)   scan(n.expression)
        if (n.condition)    scan(n.condition)
        if (n.thenPart)     scan(n.thenPart)
        if (n.elsePart)     scan(n.elsePart)
        if (n.value)        scan(n.value)
        if (n.block)        scan(n.block)
        if (n.tryBlock)     scan(n.tryBlock)
        if (n.exception)    scan(n.exception)
        if (n.discriminant) scan(n.discriminant)
        if (n.caseLabel)    scan(n.caseLabel)
        if (n.statements)   scan(n.statements)
        if (n.setup)        scan(n.setup)
        if (n.update)       scan(n.update)
        if (n.varDecl)      scan(n.varDecl)
        if (n.object)       scan(n.object)
        if (n.iterator)     scan(n.iterator)
        
    }
    scan(tree)
}

/**
 *  Dump a parse tree to a file for debugging.
 */
function dump(n) {
    strip(n)
    fs.writeFileSync('dump.json', JSON.stringify(n), 'utf8')
}

/**
 *  Prepare the parse tree for human inspection by stripping all the confusing
 *  stuff.  The process renders the tree unsuitable for decompiling.
 */
function strip(tree) {
    tree_forEach(tree, function(n) {
        delete n.tokenizer
        delete n.lineno
        delete n.start
        delete n.end
        delete n.target // break -> switch
        if (typeof n.type === 'number') n.type = tokens[n.type] + '(' + n.type + ')'
    })
}
